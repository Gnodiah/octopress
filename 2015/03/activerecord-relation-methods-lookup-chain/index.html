
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>理解ActiveRecord::Relation.where等方法的查找链 - 一根札记</title>
  <meta name="author" content="Hayden Wei">
  <meta name="Generator" content="Jekyll & Octopress (http://octopress.org)">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://haydenwei.com//posts/2015/03/activerecord-relation-methods-lookup-chain">
  <link href="/stylesheets/screen.v1.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/octopress.min.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="一根札记" type="application/atom+xml">
  



<!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>

  

  
  <link href="/images/custom/favicon.ico" rel="icon">
</head>

<body   >
  <div id="main">
    <div id="content">
      <div>











<article class="hentry " role="article">
  
  <header>
    <h1 class="entry-title">

<a href="/posts/2015/03/activerecord-relation-methods-lookup-chain">理解ActiveRecord::Relation.where等方法的查找链</a>

</h1>

    
      <p class="meta">
        








  



Written <time datetime="2015-03-20T00:00:00+08:00" pubdate data-updated="true">March 20, 2015 at 00:00 CST</time>.
        

<span class="categories">
  Tagged
  
    <a class='category' href='/posts/tag/rails/'>Rails</a>.
  
</span>


      </p>
    
  </header>


<div class="entry-content"><p>阅读完本篇文章，你将了解到：</p>

<ul>
<li>类似 Book.where(id: 1) 这样的方法是如何执行的</li>
<li>ActiveRecord::Relation 对象是什么</li>
</ul>


<h3>理解where方法的查找链</h3>

<p>假设我们有一个名为 Book 的 model:</p>

<figure class='code'><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>再假设我们要查询id为1的那本书，以 <code>where</code> 方法为例，那么我们的查询语句一般会这样写: <code>Book.where(id: 1)</code>；但在Book类中你并没有定义 <code>where</code> 方法，那么这句代码是怎样被执行的呢？让我们一起来探究一下。</p>

<p>1、首先，Book 类中没有定义 where 方法；但由于 Book 类继承自 ActiveRecord::Base 类，因此方法调用链会去尝试调用 ActiveRecord::Base.where 方法。</p>

<p>2、通过查看ActiveRecord::Base类的源码可知，ActiveRecord::Base类也没有显式定义where方法；但ActiveRecord::Base类extend了ActiveRecord::Querying模块：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">Querying</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、ActiveRecord::Querying模块也没有显式定义where方法，它使用了<code>delegate</code>委派技术将对ActiveRecord::Querying.where的调用转换为调用scoped.where，源码如下：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/querying.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:uniq</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:scoped</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、可见，Rails将where、group、includes等常用的查询方法都代理到了scoped之上。那么scoped是什么呢？它是ActiveRecord::Scoping::Named模块里的一个方法，用于创建一个空的scope:</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping/named.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">scoped</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">options</span>
</span><span class='line'>    <span class="n">scoped</span><span class="o">.</span><span class="n">apply_finder_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">current_scope</span>
</span><span class='line'>      <span class="n">current_scope</span><span class="o">.</span><span class="n">clone</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span>
</span><span class='line'>      <span class="n">scope</span><span class="o">.</span><span class="n">default_scoped</span> <span class="o">=</span> <span class="kp">true</span>
</span><span class='line'>      <span class="n">scope</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、由于我们调用scoped.where时并没有传入options和current_scope这两个参数，因此scoped方法的执行逻辑会进入到最后一个else语句。那么问题来了，这里的scoped方法是属于谁的呢，怎么可以直接被Book类调用呢？</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Scoping</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>    <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>      <span class="kp">include</span> <span class="no">Named</span> <span class="c1"># ActiveRecord::Scoping模块include了ActiveRecord::Scoping::Named模块</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From:  ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Scoping</span> <span class="c1"># 而ActiveRecord::Base又include了ActiveRecord::Scoping模块</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>6、ActiveRecord::Base类通过include ActiveRecord::Scoping模块而引入了scoping方法，因此Book类才能够调用。现在回到上一步，由于执行逻辑进入了最后一个else语句，那么代码<code>scope = relation</code>会首先被执行。<code>relation</code>是定义在ActiveRecord::Base类的一个private方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">private</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">relation</span>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span>
</span><span class='line'>    <span class="n">relation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">)</span><span class="o">.</span><span class="n">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="o">.</span><span class="n">to_sym</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">relation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>7、可以看出，ActiveRecord::Base.relation方法很简单，仅仅new了一个ActiveRecord::Relation实例便返回了。其中self表示当前的调用类，即本例的Book类。也就是说，ActiveRecord::Base.relation方法返回了一个包含当前调用类表字段信息的Relation对象。</p>

<p>8、第7步完成后，就表示完成了对<code>scoped</code>方法的调用，返回的是一个ActiveRecord::Relation对象。还记得第3步中所说的吗？对ActiveRecord::Base.where的调用委派为调用scoped.where；现在由于<code>scoped</code>返回的是ActiveRecord::Relation对象，因此就转换为调用ActiveRecord::Relation#where方法了。ActiveRecord::Relation通过include ActiveRecord::QueryMethods模块引入了where方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation.rb</span></figcaption><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Relation</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">FinderMethods</span><span class="p">,</span> <span class="no">Calculations</span><span class="p">,</span> <span class="no">SpawnMethods</span><span class="p">,</span> <span class="no">QueryMethods</span><span class="p">,</span> <span class="no">Batches</span><span class="p">,</span> <span class="no">Explain</span><span class="p">,</span> <span class="no">Delegation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From: ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation/query_methods.rb</span>
</span><span class='line'><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">self</span> <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">blank?</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="nb">clone</span>
</span><span class='line'>  <span class="n">relation</span><span class="o">.</span><span class="n">where_values</span> <span class="o">+=</span> <span class="n">build_where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="n">relation</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>9、where方法中需要注意的是<code>build_where</code>这个方法，该方法会最终调用ActiveRecord::Sanitization.sanitize_sql_for_conditions方法来将你传入到where方法中的查询条件转化为一个有效的SQL语句字符串片段。<strong>值得注意的是以Hash的形式传入时是有所不同的。</strong>例如：</p>

<figure class='code'><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span>  <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span> <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1">#=&gt; 返回包含id=1查询条件的Arel::Nodes::Equality对象数组</span>
</span></code></pre></td></tr></table></div></figure>


<p>10、当build_where方法返回后，整个<code>where</code>方法也就是返回了。到此为止，你对<code>books = Book.where(id: 1)</code>的调用就算是完全执行完了。那么得到的books是什么呢？是你想要的id为1的这本书的信息吗？不是！从上面整个执行过程我们已经得到答案了，<strong>这里的books只是一个ActiveRecord::Relation对象，该对象包含了当前调用类Book的表信息，还包含了需要执行的查询条件的SQL语句，仅此而已。也就是说，这时并没有真正地去连接数据库进行查询。</strong>那么问题又来了，Rails什么时候才去查询数据库呢？</p>

<h3>ActiveRecord::Relation对象何时查询数据库？</h3>

<p>1、想象一下我们通常对ActiveRecord::Relation对象做些什么操作？比如上面得到的books对象，我们通常会有这样的操作：</p>

<figure class='code'><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">books</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">p</span> <span class="n">book</span><span class="o">.</span><span class="n">id</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、books是一个ActiveRecord::Relation对象，那么ActiveRecord::Relation.each方法是什么呢？</p>

<figure class='code'><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:to_xml</span><span class="p">,</span> <span class="ss">:to_yaml</span><span class="p">,</span> <span class="ss">:length</span><span class="p">,</span> <span class="ss">:collect</span><span class="p">,</span> <span class="ss">:map</span><span class="p">,</span> <span class="ss">:each</span><span class="p">,</span> <span class="ss">:all?</span><span class="p">,</span> <span class="ss">:include?</span><span class="p">,</span> <span class="ss">:to_ary</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:to_a</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、可见Rails将我们常用的each、map等方法都委派到了ActiveRecord::Relation.to_a方法上:</p>

<figure class='code'><div class='highlight'><table><td class='gutter'><pre class='line-numbers'><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">to_a</span>
</span><span class='line'>  <span class="c1"># We monitor here the entire execution rather than individual SELECTs</span>
</span><span class='line'>  <span class="c1"># because from the point of view of the user fetching the records of a</span>
</span><span class='line'>  <span class="c1"># relation is a single unit of work. You want to know if this call takes</span>
</span><span class='line'>  <span class="c1"># too long, not if the individual queries take too long.</span>
</span><span class='line'>  <span class="c1">#</span>
</span><span class='line'>  <span class="c1"># It could be the case that none of the queries involved surpass the</span>
</span><span class='line'>  <span class="c1"># threshold, and at the same time the sum of them all does. The user</span>
</span><span class='line'>  <span class="c1"># should get a query plan logged in that case.</span>
</span><span class='line'>  <span class="n">logging_query_plan</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">exec_queries</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、继续升入to_a方法内部，它调用exec_queries方法</p>
</div>



  <footer>
    <p class="meta">
      

    </p>
    
      <div class="sharing">
  
  
  
  

</div>

    
    <p class="meta">
      
        <p>
          <strong>Newer:</strong>
          <a href="/posts/2015/04/rails-config-usage">rails_config的正确使用姿势</a>
        </p>
      
      
        <p>
          <strong>Older:</strong>
          <a href="/posts/2015/03/cloud-computing-and-openshift">谈谈对云计算的一些理解</a>
        </p>
      
    </p>
  </footer>
</article>

<section>
  

  
</section>

</div>

<aside class="sidebar">
  
    <header class="site-header">
  <div class="the-pug">
    <a href="/">
      <img src="/images/custom/pug_1x.png" srcset="/images/custom/pug_2x.png 2x, /images/custom/pug_3x.png 3x" alt="">
    </a>
  </div>
  <h1 class="site-title"><a href="/">一根札记</a></h1>
  <p class="site-intro">
    A blog by <a href="http://haydenwei.com/">Hayden Wei</a>.
    <a href="/atom.xml">Subscribe by RSS.</a>
  </p>

  <p class="site-intro">
    Follow <a href="https://twitter.com/gnodiahwei">@gnodiahwei</a> on Twitter.
  </p>

  
</header>









  
</aside>


<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2026742"></script>
<!-- UY END -->

    </div>
  </div>
  <footer class="blog-footer" role="contentinfo"><p>
  Unless otherwise noted, code is <a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a> and graphics (excluding the blog art) is <a href="http://creativecommons.org/licenses/by/3.0/">CC BY License</a>.
</p>

<p>
  &copy; 2015 Hayden Wei.
  <a href="http://johannaost.com/813-the-pug-automatic">Pug art</a>
  by <a href="http://johannaost.com">Johanna Öst</a>.
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a>, with a custom theme.</span>
</p>

</footer>
  



  

  

  





</body>
</html>
