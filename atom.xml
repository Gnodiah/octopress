<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一根札记]]></title>
  <link href="http://haydenwei.com/atom.xml" rel="self"/>
  <link href="http://haydenwei.com/"/>
  <updated>2015-12-10T21:24:16+08:00</updated>
  <id>http://haydenwei.com/</id>
  <author>
    <name><![CDATA[Hayden Wei]]></name>
    <email><![CDATA[your-email@domain.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[Elixir block keywords]]></title>
<link href="http://haydenwei.com/posts/2015/12/elixir-block-keywords"/>
<updated>2015-12-03T22:25:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/12/elixir-block-keywords</id>

      <content type="html"><![CDATA[<p>Exploring Elixir, I tried this:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">foobar</span><span class="p">(</span><span class="k">do</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span> <span class="k">else</span><span class="p">:</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">foobar</span> <span class="k">do</span>
</span><span class='line'><span class="k"> </span><span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;true&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;false&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it worked. Well, in a sense. The code runs, but it outputs <em>both</em> &#8220;true&#8221; and &#8220;false&#8221;.</p>

<p>What&#8217;s going on here? Let&#8217;s try another experiment:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='elixir'><span class='line'><span class="no">IO</span><span class="o">.</span><span class="n">inspect</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="s2">&quot;true&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;false&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># =&gt; [do: &quot;true&quot;, else: &quot;false&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://groups.google.com/forum/#!topic/elixir-lang-talk/jVqCeLcaUV0/discussion">Turns out</a> this is language-level syntactic sugar (e.g. <a href="https://github.com/elixir-lang/elixir/blob/c37ea4e8740539918683eb03ca9fce28239a3cac/lib/elixir/src/elixir_tokenizer.erl#L1050-L1053">1</a>, <a href="https://github.com/elixir-lang/elixir/blob/c37ea4e8740539918683eb03ca9fce28239a3cac/lib/elixir/src/elixir_exp_clauses.erl">2</a>, <a href="https://github.com/elixir-lang/elixir/blob/c37ea4e8740539918683eb03ca9fce28239a3cac/lib/elixir/lib/macro.ex#L652">3</a>) that desugars to a plain keyword list. And that explains why the code above would output both &#8220;true&#8221; and &#8220;false&#8221; – it&#8217;s equivalent to</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='elixir'><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">foobar</span><span class="p">([</span><span class="k">do</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;true&quot;</span><span class="p">),</span> <span class="k">else</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="s2">&quot;false&quot;</span><span class="p">)])</span>
</span></code></pre></td></tr></table></div></figure>


<p>The keyword list is evaluated before it&#8217;s even passed to the function, like any keyword list would be. That includes evaluating the <code>IO.puts</code> function calls.</p>

<p>Now that we have the full list of block keywords (from the Elixir source) we can go completely crazy:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='elixir'><span class='line'><span class="no">IO</span><span class="o">.</span><span class="n">inspect</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="s2">&quot;a&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="s2">&quot;b&quot;</span>
</span><span class='line'><span class="k">catch</span>
</span><span class='line'>  <span class="s2">&quot;c&quot;</span>
</span><span class='line'><span class="k">rescue</span>
</span><span class='line'>  <span class="s2">&quot;d&quot;</span>
</span><span class='line'><span class="k">after</span>
</span><span class='line'>  <span class="s2">&quot;e&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># =&gt; [do: &quot;a&quot;, else: &quot;b&quot;, catch: &quot;c&quot;, rescue: &quot;d&quot;, after: &quot;e&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So these are all available to your own functions, like in our <code>Example.foobar</code> example. But what use are they if every branch is evaluated all the time?</p>

<p>Macros to the rescue.</p>

<p><a href="https://xkcd.com/208/"><img src="https://s3.amazonaws.com/f.cl.ly/items/1a201F0e150Y3E1s2X2f/everybody_stand_back.png" alt="" class="center no-box"></a></p>

<p><a href="http://elixir-lang.org/getting-started/meta/macros.html">Elixir macros</a> get access to the syntax tree of a piece of code, without the code being evaluated first. They can then slice and dice the code and return another syntax tree, that <em>will</em> be evaluated.</p>

<p>Elixir&#8217;s own <code>if/do/else</code> is <a href="https://github.com/elixir-lang/elixir/blob/c37ea4e8740539918683eb03ca9fce28239a3cac/lib/elixir/lib/kernel.ex#L2321-L2341">just a macro</a> using these keyword lists.</p>

<p>Just for fun, we could make a macro that randomly executes one of two branches, and then always runs the <code>after</code> branch:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">MyMacro</span> <span class="k">do</span>
</span><span class='line'><span class="k">  defmacro</span> <span class="n">pick</span><span class="p">([</span><span class="k">do</span><span class="p">:</span> <span class="n">option1</span><span class="p">,</span> <span class="k">else</span><span class="p">:</span> <span class="n">option2</span><span class="p">,</span> <span class="k">after</span><span class="p">:</span> <span class="n">after_block</span><span class="p">])</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="ss">:os</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">option</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">random</span><span class="p">([</span><span class="n">option1</span><span class="p">,</span> <span class="n">option2</span><span class="p">])</span>
</span><span class='line'>    <span class="p">[</span><span class="n">option</span><span class="p">,</span> <span class="n">after_block</span><span class="p">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">require</span> <span class="no">MyMacro</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">run</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="no">MyMacro</span><span class="o">.</span><span class="n">pick</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="no">IO</span><span class="o">.</span><span class="n">write</span> <span class="s2">&quot;dog&quot;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="no">IO</span><span class="o">.</span><span class="n">write</span> <span class="s2">&quot;cat&quot;</span>
</span><span class='line'>    <span class="k">after</span>
</span><span class='line'>      <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="s2">&quot;!&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Example</span><span class="o">.</span><span class="n">run</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Outputs either of these:</span>
</span><span class='line'><span class="c1"># dog!</span>
</span><span class='line'><span class="c1"># cat!</span>
</span></code></pre></td></tr></table></div></figure>


<p>I haven&#8217;t used this myself, other than in silly experiments. I can picture it being handy for some DSLs, though. If you apply this to anything interesting, please do let me know in a comment!</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[Unforgettable attributes]]></title>
<link href="http://haydenwei.com/posts/2015/11/unforgettable-attributes"/>
<updated>2015-11-14T08:55:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/11/unforgettable-attributes</id>

      <content type="html"><![CDATA[<p><em>This blog post describes a design pattern for ensuring you consider every attribute in certain situations. I&#8217;ll use Ruby on Rails in the examples, but the general pattern should apply to any language or framework.</em></p>

<h2>The problem</h2>

<p>On <a href="http://dev.auctionet.com">our</a> <a href="https://auctionet.com">auction site</a>, there are &#8220;lots&#8221; (items for sale). Each lot has a title, description, a cached &#8220;highest bid amount&#8221; and several more attributes.</p>

<p>(I&#8217;m simplifying the data model for the sake of the example. It&#8217;s actually composed of more than one model, and doesn&#8217;t work precisely as described here.)</p>

<p>If a lot goes unsold, it may be relisted. Since we want to keep the history of listings, we make a copy.</p>

<p>So what should we copy? The title and description should be included. The highest bid amount should not, since the new listing won&#8217;t have any bids to start with.</p>

<p>Alright, we&#8217;ll write our code:</p>

<figure class='code'><figcaption><span>relister.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">includes</span> <span class="o">=</span> <span class="sx">%w[ title description ]</span>
</span><span class='line'><span class="n">new_lot</span> <span class="o">=</span> <span class="no">Lot</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">new_lot</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="n">old_lot</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">includes</span><span class="p">)</span>
</span><span class='line'><span class="n">new_lot</span><span class="o">.</span><span class="n">save!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then a few months later, someone adds an &#8220;artist&#8221; attribute. They forgot all about our relister, so relisted lots don&#8217;t carry it over as we would have liked.</p>

<p>We could instead list the attributes to <em>exclude</em>, but then if someone adds a new attribute and forgets to revise the relister, we would include that new attribute even if we shouldn&#8217;t.</p>

<h2>The solution</h2>

<p>The solution we settled on for situations like this is to list all includes <em>and</em> excludes.</p>

<p>When we relist, we go through every attribute. We include the ones we should, ignore the ones we shouldn&#8217;t, and raise an exception if we encounter a new attribute that we don&#8217;t know how to handle.</p>

<p>This is that rare thing, a perfect solution. We&#8217;re guaranteed that we can&#8217;t forget to declare how to handle a new attribute. If we do, we&#8217;ll be told.</p>

<p>If the relisting is covered by integrated tests at all, they will trigger these exceptions as soon as you add a new attribute and forget to declare it.</p>

<h3>Example code</h3>

<figure class='code'><figcaption><span>relister.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">new_lot</span> <span class="o">=</span> <span class="no">Lot</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="n">new_lot</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="no">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span><span class="o">.</span><span class="n">attributes_from_lot</span><span class="p">(</span><span class="n">old_lot</span><span class="p">)</span>
</span><span class='line'><span class="n">new_lot</span><span class="o">.</span><span class="n">save!</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>lot/includes_and_excludes.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span>
</span><span class='line'>  <span class="no">LOT_INCLUDES</span> <span class="o">=</span> <span class="o">[</span>
</span><span class='line'>    <span class="ss">:title</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:description</span><span class="p">,</span>
</span><span class='line'>  <span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">LOT_EXCLUDES</span> <span class="o">=</span> <span class="o">[</span>
</span><span class='line'>    <span class="ss">:id</span><span class="p">,</span> <span class="ss">:created_at</span><span class="p">,</span> <span class="ss">:updated_at</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">:highest_bid_amount</span><span class="p">,</span>
</span><span class='line'>  <span class="o">]</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">attributes_from_lot</span><span class="p">(</span><span class="n">lot</span><span class="p">)</span>
</span><span class='line'>    <span class="kp">new</span><span class="p">(</span><span class="n">lot</span><span class="p">,</span> <span class="no">LOT_INCLUDES</span><span class="p">,</span> <span class="no">LOT_EXCLUDES</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">includes</span><span class="p">,</span> <span class="n">excludes</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@record</span><span class="p">,</span> <span class="vi">@includes</span><span class="p">,</span> <span class="vi">@excludes</span> <span class="o">=</span> <span class="n">record</span><span class="p">,</span> <span class="n">includes</span><span class="p">,</span> <span class="n">excludes</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">attributes</span>
</span><span class='line'>    <span class="n">attributes</span> <span class="o">=</span> <span class="vi">@record</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">symbolize_keys</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">attributes</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">each_with_object</span><span class="p">({})</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="nb">hash</span><span class="o">|</span>
</span><span class='line'>      <span class="k">if</span> <span class="vi">@includes</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>        <span class="nb">hash</span><span class="o">[</span><span class="nb">name</span><span class="o">]</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>      <span class="k">elsif</span> <span class="vi">@excludes</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># Ignore this known exclude.</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>        <span class="k">raise</span> <span class="s2">&quot;Don&#39;t know whether or not to include </span><span class="si">#{</span><span class="vi">@record</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">#</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>attributes_for_lot</code> class method passes in the constants to the instance, to illustrate how it may work if you&#8217;re dealing with more than one model. In the real world, we have more than one model in place of <code>Lot</code>.</p>

<p>This also makes it very easy to test – and you can test it lightning-fast without loading Rails, if you have that set up.</p>

<figure class='code'><figcaption><span>spec/lot/includes_and_excludes_spec.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">describe</span> <span class="no">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span><span class="p">,</span> <span class="s2">&quot;#attributes&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">it</span> <span class="s2">&quot;includes the attributes to include&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">record</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="n">attributes</span><span class="p">:</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">42</span> <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">actual</span> <span class="o">=</span> <span class="no">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:name</span> <span class="o">]</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:age</span> <span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="kp">include</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">it</span> <span class="s2">&quot;excludes the attributes to exclude&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">record</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="n">attributes</span><span class="p">:</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">42</span> <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">actual</span> <span class="o">=</span> <span class="no">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:name</span> <span class="o">]</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:age</span> <span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span><span class="o">.</span><span class="n">not_to</span> <span class="kp">include</span><span class="p">(</span><span class="ss">:age</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">it</span> <span class="s2">&quot;raises if an undeclared attribute is present&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">record</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span>
</span><span class='line'>      <span class="n">attributes</span><span class="p">:</span> <span class="p">{</span> <span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="n">location</span><span class="p">:</span> <span class="s2">&quot;Bar&quot;</span> <span class="p">},</span>
</span><span class='line'>      <span class="n">class</span><span class="p">:</span> <span class="n">double</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;MyClass&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">expect</span> <span class="p">{</span>
</span><span class='line'>      <span class="no">Lot</span><span class="o">::</span><span class="no">IncludesAndExcludes</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:name</span> <span class="o">]</span><span class="p">,</span> <span class="o">[</span> <span class="ss">:age</span> <span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">attributes</span>
</span><span class='line'>    <span class="p">}</span><span class="o">.</span><span class="n">to</span> <span class="n">raise_error</span><span class="p">(</span><span class="sr">/MyClass#location/</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Other uses</h2>

<p>This can be used for anything, of course. We&#8217;ve used it for relisting things and for cloning things more generally.</p>

<p>Most recently, we used it for reversing financial vouchers in an accounting system: basically, you create a copy but invert some of the numbers. For the copy part, we employed this pattern.</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[rails_config的正确使用姿势]]></title>
<link href="http://haydenwei.com/posts/2015/04/rails-config-usage"/>
<updated>2015-04-26T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/04/rails-config-usage</id>

      <content type="html"><![CDATA[<h3>前言</h3>

<p>Rails中的<code>Settings</code>并不是Rails自带的，而是<code>rails_config</code>这个gem包提供给我们的。虽然Settings看起来是一个常量(<em>因为以大写字母开头</em>)，但实际上它是RailsConfig::Options类的一个实例对象，包含了当前项目中所有settings文件中配置的key-value对。</p>

<p>其有两种使用方式：</p>

<ul>
<li>Settings.key(.sub_key)</li>
<li>Settings[:key][:sub_key] 或 Settings[&#8216;key&#8217;][&#8216;sub_key&#8217;]</li>
</ul>


<h3>Settings使用姿势说明</h3>

<p><a href="https://github.com/railsconfig/rails_config">rails_config</a>默认的settings文件有6个，分别为:</p>

<ul>
<li>config/settings.yml</li>
<li>config/settings.local.yml</li>
<li>config/settings/#{Rails.env}.yml</li>
<li>config/settings/#{Rails.env}.local.yml</li>
<li>config/environments/#{Rails.env}.yml</li>
<li>config/environments/#{Rails.env}.local.yml</li>
</ul>


<p>因此，在使用Settings过程中会存在两个问题：</p>

<ol>
<li>同一个setting文件的内容是如何被解析的？</li>
<li>不同settings文件的内容是如何被解析和合并的？</li>
</ol>


<p>我们先来看结果：</p>

<p>1、同一个setting文件中的相同key之间是<strong>覆盖关系</strong>。(后者会直接整个覆盖掉前者，不会对子节点key进行合并)</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: config/settings.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">1</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">2</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; 2</span>
</span><span class='line'>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="mi">127</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">8983</span>
</span><span class='line'>  <span class="n">path</span><span class="p">:</span> <span class="sr">/solr/moni</span><span class="n">tor</span>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="mi">192</span><span class="o">.</span><span class="mi">168</span><span class="o">.</span><span class="mi">100</span><span class="o">.</span><span class="mi">46</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.solr.host #=&gt; 192.168.100.46</span>
</span><span class='line'><span class="c1"># Settings.solr.port #=&gt; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、同一个setting文件与其local文件中相同key之间是<strong>合并关系</strong>。(local文件优先级更高)</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: config/settings.yml</span>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="mi">127</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">8983</span>
</span><span class='line'>  <span class="n">path</span><span class="p">:</span> <span class="sr">/solr/moni</span><span class="n">tor</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File: config/settings.local.yml</span>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">username</span><span class="p">:</span> <span class="s1">&#39;Hayden&#39;</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">12121</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.solr.host #=&gt; &quot;http://127.0.0.1&quot;</span>
</span><span class='line'><span class="c1"># Settings.solr.port #=&gt; 12121</span>
</span><span class='line'><span class="c1"># Settings.solr.username #=&gt; &quot;Hayden&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、不同settings文件的key之间的关系是<strong>合并关系</strong>。且优先级关系为:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='sh'><span class='line'>environments/#<span class="o">{</span>Rails.env<span class="o">}</span>.local.yml &gt; settings/#<span class="o">{</span>Rails.env<span class="o">}</span>.local.yml &gt; settings.local.yml
</span><span class='line'>&gt; environments/#<span class="o">{</span>Rails.env<span class="o">}</span>.yml &gt; settings/#<span class="o">{</span>Rails.env<span class="o">}</span>.yml &gt; settings.yml
</span></code></pre></td></tr></table></div></figure>


<p>4、不同settings文件的相同key在合并过程中的原则是：</p>

<ul>
<li>如果key对应的value是不同类型或不可合并的类型时，对value进行覆盖；</li>
<li>如果key对应的value是可以合并的类型(比如数组)时，则对value进行合并。</li>
</ul>


<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: config/settings.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">88</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File: config/settings.local.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; [11, 88, 23, 45]</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、在第4点中，如果中途被打断，则还是会对value进行覆盖操作，而不是合并。</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: config/settings.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">88</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File: config/settings/development.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">2</span>   <span class="c1"># 这里中途被不同类型的value打断</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File: config/settings.local.yml</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; [23, 45]</span>
</span></code></pre></td></tr></table></div></figure>


<p>6、在development模式下，每一次页面请求都会调用<code>Settings.reload!</code>来重新加载和解析所有的settings文件，因此理论上修改了settings文件后不需要重启Rails。
7、在settings文件中是允许内嵌ruby代码的，这在某些情况下很有用。例如：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: config/settings.yml</span>
</span><span class='line'><span class="n">size</span><span class="p">:</span> <span class="mi">2</span>
</span><span class='line'><span class="n">computed</span><span class="p">:</span> <span class="o">&lt;</span><span class="sx">%= 1 + 2 + 3 %&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sx"># Settings.computed #=</span><span class="o">&gt;</span> <span class="mi">6</span>
</span></code></pre></td></tr></table></div></figure>


<h3>追根溯源</h3>

<p>我们先来了解下rails_config在Rails启动过程中做了什么：</p>

<p>1、加载config/initializers/rails_config.rb文件(该文件是rails_config的自定义文件。例如，如果你不想使用默认的Settings来引用配置文件，就可以在该文件中进行修改其常量名称。如下)</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">RailsConfig</span><span class="o">.</span><span class="n">setup</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">const_name</span> <span class="o">=</span> <span class="s2">&quot;MySettings&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、加载所有默认的settings配置文件，将其解析为一个RailsConfig::Options(继承自<a href="http://ruby-doc.org/stdlib-2.1.1/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a>，是一个类似于Hash的数据结构)对象，并将该对象赋值给Settings常量，以便我们通过<code>Settings.xxx</code>的方式来调用。</p>

<hr />

<p><strong>Q1: 上面所说的6个settings文件是有优先级的，为什么必须是这样的顺序呢？</strong></p>

<p><strong>A1:</strong> 没有其他原因，仅仅是因为rails_config的代码中是这样定义死的，源码如下：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># File: lib/rails_config/integration/rails.rb +14</span>
</span><span class='line'><span class="no">RailsConfig</span><span class="o">.</span><span class="n">load_and_set_settings</span><span class="p">(</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;environments&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;environments&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难看出，方法传入的是一个数组参数，在用<code>each</code>遍历时，后者必然会覆盖前者，因而自然就产生了如上所说的优先级顺序。</p>

<p><strong>Q2: 我不想使用默认的优先级顺序，我想在运行时改变它们之间的顺序；我还想加入自己的yml配置文件&#8230;可以吗？</strong></p>

<p><strong>A2:</strong> 完全没有问题。</p>

<p>1、如果想在默认的6个settings配置文件基础上加入自己的yml配置文件，你可以在程序中任何需要的地方加入如下代码片段：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">add_source!</span><span class="p">(</span><span class="s2">&quot;/path/to/my_settings.yml&quot;</span><span class="p">)</span>
</span><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">reload!</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时你的my_settings.yml文件中的配置就可以直接用<code>Settings.xxx</code>来调用了，而且你的my_settings.yml文件拥有最高的优先级。</p>

<p>2、如果你想完全自定义需要加载的settings文件及其顺序，可以在程序中任何需要的地方加入如下代码片段：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">reload_from_files</span><span class="p">(</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;my_settings.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样Settings中就只包含了settings.local.yml和my_settings.yml中的配置。</p>

<p><strong>Q3: 我很好奇它的解析和合并算法，它是怎么实现的呢？</strong></p>

<p><strong>A3:</strong> 这是rails_config中最核心和最重要的部分了，其实现封装在<code>DeepMerge</code>这个module中。如有兴趣可以直接阅读源码来了解它的实现，<a href="https://github.com/railsconfig/rails_config/blob/master/lib/rails_config/vendor/deep_merge.rb">源码传送门在这里</a>。</p>

<p>就算你不想看它的实现，但了解它的存在也是有必要的。因为如果以后你自己的项目中遇到要解析和合并多个yml文件的内容时，可以直接拿来使用，或者参考它的实现，毕竟我们还是要把时间用在更有意义的地方，避免重复造轮子嘛。</p>

<blockquote><p>注： 以上内容基于<code>rails_config -v 0.3.1</code>，目前rails_config的最新稳定版为0.4.2。虽然版本有所升级，但核心设计应该不会有变化。如有疑问，欢迎指出并留言讨论。</p></blockquote>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[理解ActiveRecord::Relation.where等方法的查找链]]></title>
<link href="http://haydenwei.com/posts/2015/03/activerecord-relation-methods-lookup-chain"/>
<updated>2015-03-20T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/03/activerecord-relation-methods-lookup-chain</id>

      <content type="html"><![CDATA[<p>阅读完本篇文章，你将了解到：</p>

<ul>
<li>类似 Book.where(id: 1) 这样的方法是如何执行的</li>
<li>ActiveRecord::Relation 对象是什么</li>
</ul>


<h3>理解where方法的查找链</h3>

<p>假设我们有一个名为 Book 的 model:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>再假设我们要查询id为1的那本书，以 <code>where</code> 方法为例，那么我们的查询语句一般会这样写: <code>Book.where(id: 1)</code>；但在Book类中你并没有定义 <code>where</code> 方法，那么这句代码是怎样被执行的呢？让我们一起来探究一下。</p>

<p>1、首先，Book 类中没有定义 where 方法；但由于 Book 类继承自 ActiveRecord::Base 类，因此方法调用链会去尝试调用 ActiveRecord::Base.where 方法。</p>

<p>2、通过查看ActiveRecord::Base类的源码可知，ActiveRecord::Base类也没有显式定义where方法；但ActiveRecord::Base类extend了ActiveRecord::Querying模块：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">Querying</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、ActiveRecord::Querying模块也没有显式定义where方法，它使用了<code>delegate</code>委派技术将对ActiveRecord::Querying.where的调用转换为调用scoped.where，源码如下：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/querying.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:uniq</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:scoped</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、可见，Rails将where、group、includes等常用的查询方法都代理到了scoped之上。那么scoped是什么呢？它是ActiveRecord::Scoping::Named模块里的一个方法，用于创建一个空的scope:</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping/named.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">scoped</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">options</span>
</span><span class='line'>    <span class="n">scoped</span><span class="o">.</span><span class="n">apply_finder_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">current_scope</span>
</span><span class='line'>      <span class="n">current_scope</span><span class="o">.</span><span class="n">clone</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span>
</span><span class='line'>      <span class="n">scope</span><span class="o">.</span><span class="n">default_scoped</span> <span class="o">=</span> <span class="kp">true</span>
</span><span class='line'>      <span class="n">scope</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、由于我们调用scoped.where时并没有传入options和current_scope这两个参数，因此scoped方法的执行逻辑会进入到最后一个else语句。那么问题来了，这里的scoped方法是属于谁的呢，怎么可以直接被Book类调用呢？</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Scoping</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>    <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>      <span class="kp">include</span> <span class="no">Named</span> <span class="c1"># ActiveRecord::Scoping模块include了ActiveRecord::Scoping::Named模块</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From:  ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Scoping</span> <span class="c1"># 而ActiveRecord::Base又include了ActiveRecord::Scoping模块</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>6、ActiveRecord::Base类通过include ActiveRecord::Scoping模块而引入了scoping方法，因此Book类才能够调用。现在回到上一步，由于执行逻辑进入了最后一个else语句，那么代码<code>scope = relation</code>会首先被执行。<code>relation</code>是定义在ActiveRecord::Base类的一个private方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">private</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">relation</span>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span>
</span><span class='line'>    <span class="n">relation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">)</span><span class="o">.</span><span class="n">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="o">.</span><span class="n">to_sym</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">relation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>7、可以看出，ActiveRecord::Base.relation方法很简单，仅仅new了一个ActiveRecord::Relation实例便返回了。其中self表示当前的调用类，即本例的Book类。也就是说，ActiveRecord::Base.relation方法返回了一个包含当前调用类表字段信息的Relation对象。</p>

<p>8、第7步完成后，就表示完成了对<code>scoped</code>方法的调用，返回的是一个ActiveRecord::Relation对象。还记得第3步中所说的吗？对ActiveRecord::Base.where的调用委派为调用scoped.where；现在由于<code>scoped</code>返回的是ActiveRecord::Relation对象，因此就转换为调用ActiveRecord::Relation#where方法了。ActiveRecord::Relation通过include ActiveRecord::QueryMethods模块引入了where方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Relation</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">FinderMethods</span><span class="p">,</span> <span class="no">Calculations</span><span class="p">,</span> <span class="no">SpawnMethods</span><span class="p">,</span> <span class="no">QueryMethods</span><span class="p">,</span> <span class="no">Batches</span><span class="p">,</span> <span class="no">Explain</span><span class="p">,</span> <span class="no">Delegation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From: ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation/query_methods.rb</span>
</span><span class='line'><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">self</span> <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">blank?</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="nb">clone</span>
</span><span class='line'>  <span class="n">relation</span><span class="o">.</span><span class="n">where_values</span> <span class="o">+=</span> <span class="n">build_where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="n">relation</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>9、where方法中需要注意的是<code>build_where</code>这个方法，该方法会最终调用ActiveRecord::Sanitization.sanitize_sql_for_conditions方法来将你传入到where方法中的查询条件转化为一个有效的SQL语句字符串片段。<strong>值得注意的是以Hash的形式传入时是有所不同的。</strong>例如：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span>  <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span> <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1">#=&gt; 返回包含id=1查询条件的Arel::Nodes::Equality对象数组</span>
</span></code></pre></td></tr></table></div></figure>


<p>10、当build_where方法返回后，整个<code>where</code>方法也就是返回了。到此为止，你对<code>books = Book.where(id: 1)</code>的调用就算是完全执行完了。那么得到的books是什么呢？是你想要的id为1的这本书的信息吗？不是！从上面整个执行过程我们已经得到答案了，<strong>这里的books只是一个ActiveRecord::Relation对象，该对象包含了当前调用类Book的表信息，还包含了需要执行的查询条件的SQL语句，仅此而已。也就是说，这时并没有真正地去连接数据库进行查询。</strong>那么问题又来了，Rails什么时候才去查询数据库呢？</p>

<h3>ActiveRecord::Relation对象何时查询数据库？</h3>

<p>1、想象一下我们通常对ActiveRecord::Relation对象做些什么操作？比如上面得到的books对象，我们通常会有这样的操作：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">books</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">p</span> <span class="n">book</span><span class="o">.</span><span class="n">id</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、books是一个ActiveRecord::Relation对象，那么ActiveRecord::Relation.each方法是什么呢？</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:to_xml</span><span class="p">,</span> <span class="ss">:to_yaml</span><span class="p">,</span> <span class="ss">:length</span><span class="p">,</span> <span class="ss">:collect</span><span class="p">,</span> <span class="ss">:map</span><span class="p">,</span> <span class="ss">:each</span><span class="p">,</span> <span class="ss">:all?</span><span class="p">,</span> <span class="ss">:include?</span><span class="p">,</span> <span class="ss">:to_ary</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:to_a</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、可见Rails将我们常用的each、map等方法都委派到了ActiveRecord::Relation.to_a方法上:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">to_a</span>
</span><span class='line'>  <span class="c1"># We monitor here the entire execution rather than individual SELECTs</span>
</span><span class='line'>  <span class="c1"># because from the point of view of the user fetching the records of a</span>
</span><span class='line'>  <span class="c1"># relation is a single unit of work. You want to know if this call takes</span>
</span><span class='line'>  <span class="c1"># too long, not if the individual queries take too long.</span>
</span><span class='line'>  <span class="c1">#</span>
</span><span class='line'>  <span class="c1"># It could be the case that none of the queries involved surpass the</span>
</span><span class='line'>  <span class="c1"># threshold, and at the same time the sum of them all does. The user</span>
</span><span class='line'>  <span class="c1"># should get a query plan logged in that case.</span>
</span><span class='line'>  <span class="n">logging_query_plan</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">exec_queries</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、继续升入to_a方法内部，它调用exec_queries方法</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[谈谈对云计算的一些理解]]></title>
<link href="http://haydenwei.com/posts/2015/03/cloud-computing-and-openshift"/>
<updated>2015-03-03T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/03/cloud-computing-and-openshift</id>

      <content type="html"><![CDATA[<p>现如今无论公司还是个人，都在讲云计算，似乎一听到<strong>云计算</strong>这个词就觉得高大上。那么到底什么是云计算呢？</p>

<h3>什么是云计算？</h3>

<p>目前使用最多的对云计算的定义是这样的：</p>

<blockquote><p><strong>云计算</strong>是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p></blockquote>

<p>以上是美国国家标准技术研究所（NIST）给出的定义<a href="http://www.nist.gov/itl/cloud/">^CloudComputing</a>，大家千万不要被云计算这三个字中的“计算”两个字所误导而认为这是一种关于数学计算方面的新技术；实际上它代表的是一种模型或者叫模式。</p>

<p>举个例子来说，我做了一个网站来提供图片存储服务，你通过访问网站来上传和下载你存储的图片。对于你（使用者）来说，上传的图片存到什么地方去了、后台有多少台服务器、服务器的网络带宽是多少&#8230;等等这些问题你一无所知，就像被云遮住了一样什么都看不见（整个网站服务就像是一朵云，你把图片扔进云里它就存储好了，要用的时候直接从云里去拿，至于这是一朵什么云你一概不知也不需要知道，这就是<strong>云</strong>的概念）；再加上这些服务都跟计算机或者大量计算相关，所以类似于我提供的这种服务模式就叫做<strong>云计算</strong>，而我就叫做<strong>云计算服务提供方</strong>。</p>

<p>目前云计算领域主要包含3大部分内容，即Infrastructure as a Service（IaaS，基础设施即服务）、Platform as a Service（PaaS，平台即服务）、 Software as a Service（SaaS，软件即服务）。</p>

<h3>IaaS, PaaS和SaaS的区别</h3>

<p>IaaS, PaaS和SaaS是目前云计算领域的主要组成部分。如果把整个云计算想象成一个栈的话，那么IaaS就在最底层，SaaS在最顶层，而PaaS在它们之间。</p>

<p><img src="http://7x2vza.com1.z0.glb.clouddn.com/cloud-computing.png" alt="云计算" /></p>

<ul>
<li><p><strong>IaaS（基础设施即服务）</strong></p>

<p>IaaS是一种将服务器、存储资源、网络配置、防火墙等一系列基础设备综合起来提供给用户按需付费使用的服务。</p>

<p>例如，一个公司如果需要上线一个web产品，那么运维部需要提前采购服务器、购买网络带宽、配置网络和防火墙等等，往往光是采购服务器这一步就可能需要花费一周的时间，大大延迟了产品的上线时间；而且每次新增服务器都需要重复以上过程。有了IaaS以后，你只需要考虑选择哪一个IaaS服务提供方，选定后按自己对基础资源的需求购买相应的资源即可（大部分IaaS提供方都可以免费试用），所有关于采购、配置等步骤你都不用管，你只需要在购买的资源上配置运行公司的产品所需要的环境即可。这让你仅仅聚焦于如何搭建和发布产品环境而不是繁琐的服务器采购和配置工作。</p>

<p>目前IaaS服务主要提供云存储和硬件资源虚拟化（比如上例中的服务器资源），在这方面做的最好最大的是<a href="http://aws.amazon.com/cn/">Amazon Web Service（AWS）</a>，国内也有诸如<a href="http://www.qcloud.com/">腾讯云</a>这样的服务。</p></li>
<li><p><strong>PaaS（平台即服务）</strong></p>

<p>PaaS通常是在IaaS基础上提供的一种平台服务，且多聚焦于web解决方案。它在IaaS基础上将运行某一语言所需要的环境安装好后直接提供给用户（<strong>主要是开发者</strong>）使用，让用户专注于产品的创新和快速原型的开发，而不是完成从购买服务器、安装产品运行环境到部署代码等整个繁琐的过程。</p>

<p>比如，你有一个很好的idea，已经用Rails来实现了它，现在迫切需要发布到网上进行推广验证。因此接下来你要购买一个服务器、购买域名、安装和配置Nginx、安装Ruby和Rails、安装MySQL数据库&#8230;然后部署代码进行测试是否部署成功。天啦，想想都觉得头痛！现在有了PaaS，你只需要两步：第一步选择开发平台（比如Rails），第二步提交代码，然后就可在线上进行访问了。所有有关该开发平台的环境配置、服务器配置、数据库安装都由PaaS帮你完成，让你更专注于代码开发从而快速实现一个好的创意。</p>

<p>PaaS平台现在有很多，比如GAE，OpenShift，Heroku，国内的SAE， BAE等等。</p></li>
<li><p><strong>SaaS（软件即服务）</strong></p>

<p>  回想一下我们平常是怎样使用软件的？当我们需要使用一个软件时，我们需要下载它、安装它，然后才能使用，此时该软件是实实在在存在于我们的计算机上的。比如在以前你要收发邮件时需要下载并安装邮件客户端，还需要配置POP/SMTP地址，而且还需要时刻小心垃圾邮件占尽了磁盘空间，当软件有更新时你还需要下载更新&#8230;但有了SaaS就不一样了，再想一下你使用Gmail的场景：你仅仅在浏览器中输入了一个网址，再登录以后居然就可以收发邮件了。</p>

<p>这就是SaaS，它是一种通过Internet提供软件的模式，用户无需购买和安装软件，直接向提供方租用（免费或者付费）基于Web的软件。典型的SaaS应用有Gamil, <a href="https://office.live.com">Microsoft Office Online</a>等等。</p></li>
</ul>


<p>当然，作为一名开发者，最为关心的应该就是PaaS了，因此下面就来谈谈OpenShift的使用。</p>

<h3>OpenShift的使用</h3>

<h4>1. 什么是OpenShift？</h4>

<p><a href="https://www.openshift.com/">OpenShift</a>是Red Hat公司推出的一种PaaS服务，它支持Java（Wildfly, JBossEAP, Tomcat）, PHP, Node.js, Python, Ruby, Perl, MySQL, PostgreSQL, MongoDB, Jenkins, Cron, 以及JBoss xPaaS Services (Fuse, BPM Suite, BRMS, Data Virtualization, Aerogear等等)，可以说包含了目前所有的主流开发平台。</p>

<p>OpenShift提供了3种版本：OpenShift Origin，OpenShift Online和OpenShift Enterprise。其中OpenShift Origin开源并托管于<a href="https://github.com/openshift/origin">Github</a>上，你可以用它来搭建自己的本地PaaS服务；OpenShift Online则是定期从OpenShift Origin打包发布的主要针对开发者的PaaS服务；而OpenShift Enterprise则主要提供给企业用户使用。因此作为开发者来讲，我们主要关心并使用的是OpenShift Online。</p>

<p><a href="https://www.openshift.com/app/account/new">注册</a>一个OpenShift Online账号后，每个账号就可以<strong>免费</strong>创建并部署3个小应用程序了（small gear），每个应用程序的服务器配置为 512M RAM 和 1G 存储容量，这对于个人项目或者刚刚诞生的Good idea来说已经足够了。</p>

<h4>2. 安装OpenShift</h4>

<p>OpenShift提供了3种方式来创建和管理应用程序：Web Console、客户端命令行工具rhc，以及Eclipse插件。对绝大多数开发者来说最强大最完整的方式肯定是命令行工具，因此下面就以在CentOS系统上使用命令行工具rhc创建一个Ruby应用的方式来简单介绍一下OpenShift的使用。其他系统安装rhc的方法请参考<a href="https://developers.openshift.com/en/managing-client-tools.html">这里</a>。</p>

<ul>
<li><p>准备条件</p>

<p>rhc是一个Gem包，因此你需要先安装RubyGems。Ruby 1.9+已经内置了RubyGems，所以如果你的系统上已经安装过Ruby 1.9+的版本的话，RubyGems就已经在你的系统上了。如果没有安装过请参考<a href="https://rubygems.org/pages/download">这里</a>。此外，rhc使用SSH和Git来管理和上传源代码，因此这两个工具也需要安装。</p></li>
<li><p>安装rhc</p></li>
</ul>


<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='sh'><span class='line'>gem install rhc
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>运行 <code>rhc setup</code> 按提示一步一步<a href="https://developers.openshift.com/en/getting-started-overview.html">配置rhc</a></p></li>
<li><p>配置完成后，即可创建一个应用程序：</p></li>
</ul>


<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='sh'><span class='line'><span class="c"># 可运行rhc cartridge list查看OpenShift支持的所有开发平台</span>
</span><span class='line'><span class="c"># 创建一个名称为funny的应用程序，开发平台为ruby-2.0</span>
</span><span class='line'>rhc create-app funny ruby-2.0
</span></code></pre></td></tr></table></div></figure>


<p>OK，就这4步，一个名为funny的Ruby应用程序已经创建并部署到OpenShift上了，现在你就可以访问OpenShift返回给你的应用程序URL来查看它了，厉害吧！</p>

<p>但遗憾的是上述URL并不能在华夏国内访问，因为它已经被功夫网（GFW）给封了。好在<strong>绑定独立域名后是可以访问的</strong>。具体方法为：</p>

<ol>
<li>首先在你所购买的域名的管理界面中新增域名解析CNAME类型，将OpenShift给你的应用程序的URL解析到你所购买的域名；</li>
<li>在OpenShift应用程序根目录中执行<code>rhc alias add &lt;应用程序名称&gt; &lt;你购买的域名&gt;</code>绑定独立域名。</li>
</ol>


<p>OK，刚刚部署的应用程序现在终于可以正常访问了。关于rhc的更多用法请运行<code>rhc -h</code>查看。要了解更多的OpenShift知识或查看每种开发平台的帮助文档请阅读OpenShift的<a href="https://developers.openshift.com/">开发者文档</a>。</p>

<hr />
]]></content>
    </entry>
  
</feed>
