<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[The Stick Talk]]></title>
  <link href="http://haydenwei.com/atom.xml" rel="self"/>
  <link href="http://haydenwei.com/"/>
  <updated>2015-12-24T14:41:29+08:00</updated>
  <id>http://haydenwei.com/</id>
  <author>
    <name><![CDATA[Hayden Wei]]></name>
    <email><![CDATA[your-email@domain.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
    <entry>
      




<title type="html"><![CDATA[每个Rubyist都应该构建并发布自己的Gem]]></title>
<link href="http://haydenwei.com/posts/2015/12/how-to-write-a-ruby-gem"/>
<updated>2015-12-23T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/12/how-to-write-a-ruby-gem</id>

      <content type="html"><![CDATA[<p>关于 gem 是什么，其实不用多说，每一个 Rubyist 都不会感到陌生。无论是纯 Ruby 开发还是 Rails 等框架开发，我们都在享受着 gem 带给我们的开发便利，<a href="https://rubygems.org/">RubyGems</a> 上目前已经有数十万个 gem ，总下载量也已经接近<a href="https://rubygems.org/stats">70亿次</a>。简单点说，一个 gem 就是一系列 Ruby 代码的组合，它实现了某种或某些特定的功能。打包成 gem 是为了更好地重用代码，或分享给他人使用，而不是直接简单粗暴地 copy 一份代码。</p>

<p>学习 gem 最好的资料是 <a href="http://guides.rubygems.org/">RubyGems Guides</a> ，它详细介绍了有关 gem 的很多信息，包括如何创建一个自己的 gem 。所以，我建议你把它完整地读一遍，这对你更深层次地理解 gem 有很大的好处。但对于如何创建和发布一个 gem 这一点来说， RubyGems Guides 中介绍的是如何一步一步地手动创建 gem，需要你从一个空目录开始创建所有需要的文件和子目录。太繁琐了！怎么办呢？有没有方法能够快速地生成一个 gem 包的框架，而我们只需要在此基础上完成该 gem 所要提供的功能就好了呢？</p>

<p>这就要请出我们这篇文章所要使用的 <code>bundle gem</code> 命令了。下面我们会以创建一个名为 elklogger 的 gem 来理解构建和发布 gem 的整个过程。该 gem 打算提供日志统一格式化的功能，也就是说，在引入了该 gem 的所有项目中，使用 gem 包提供的方法生成的日志的格式都是一致的。</p>

<h3>生成 gem 包框架</h3>

<p><code>bundle gem</code> 命令是由 <a href="http://bundler.io/">bundler</a> 这个 gem 包提供的，它用于创建一个 gem 包所需的框架，而不用你一个一个文件去添加。要使用这个命令，首先需要确认是否已经安装好 bundler ，可使用 <code>bundle version</code> 查看本机 bundler 的版本，结果类似于：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>Bundler version 1.11.2</span></code></pre></td></tr></table></div></figure>


<p>如果本机没有安装，则使用 <code>gem install bundler</code> 来安装它。</p>

<p>安装好 bundler 之后，就可以使用它来创建一个空白的 gem 包框架了。用法非常简单：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="n">gem</span> <span class="no">GEM_NAME</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一次使用该命令创建 gem 包时，会询问你是否创建测试目录以及是否创建 LICENSE.txt 文件等信息，该配置会保存在 ~/.bundle/config 文件中，以后再使用该命令创建 gem 包时会默认使用该配置。给 gem 添加测试代码是个好习惯，所以建议你在上面的询问信息时选择其中的一个测试框架，也可以直接给 <code>bundle gem</code> 命令添加 -t 参数来使用默认的 rspec 作为测试框架（更多关于该命令的参数可以 <code>bundle help gem</code> 来<a href="http://bundler.io/v1.11/bundle_gem.html">查看</a>）：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="n">gem</span> <span class="no">GEM_NAME</span> <span class="o">-</span><span class="n">t</span>
</span></code></pre></td></tr></table></div></figure>


<p>或使用 &#8211;test 参数来指定所要使用的测试框架：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">bundle</span> <span class="n">gem</span> <span class="no">GEM_NAME</span> <span class="o">--</span><span class="nb">test</span><span class="o">=</span><span class="n">minitest</span>
</span></code></pre></td></tr></table></div></figure>


<p>该命令做了3件事：</p>

<ul>
<li>创建指定的 gem 包目录并初始化 gem 包的基本结构</li>
<li>使用 <code>git init</code> 命令初始化新建的 gem 包目录</li>
<li>提供一些帮助你开发 gem 包的 rake 命令（可进入目录后使用 <code>rake -T</code> 查看这些 rake 命令）</li>
</ul>


<p>本例中我们使用 <code>bundle gem elklogger -t</code> 命令生成的 elklogger gem 框架结构如下：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>bin/
</span><span class='line'>  console
</span><span class='line'>  setup
</span><span class='line'>lib/
</span><span class='line'>  elklogger/
</span><span class='line'>    version.rb
</span><span class='line'>  elklogger.rb
</span><span class='line'>spec/
</span><span class='line'>  elklogger_spec.rb
</span><span class='line'>  spec_helper.rb
</span><span class='line'>elklogger.gemspec
</span><span class='line'>Gemfile
</span><span class='line'>LICENSE.txt
</span><span class='line'>Rakefile
</span><span class='line'>README.md</span></code></pre></td></tr></table></div></figure>


<h3>理解 gem 包目录结构</h3>

<p>如上面生成的框架结构所示，看起来有点让人摸不着头脑，让人觉得不知道该如何组织文件结构。但其实也很简单，我们在开发一个 gem 时，通常主要关心和修改的是如下几个部分：</p>

<ul>
<li><p><strong>lib 目录</strong></p>

<p>lib 目录用于存放 gem 包所要实现的功能的源代码。而且在 lib 根目录下必须有一个与 gem 包名字一样的 .rb 文件，这是 gem 包的入口文件（如本例中的 lib/elklogger.rb）。其它的源代码可以在 lib 下按需组织目录结构，然后再 require 到 gem 包的入口文件中即可。</p></li>
<li><p><strong>spec 目录或 test 目录</strong></p>

<p>这是书写和存放 gem 包测试代码的目录。根据你选择的测试框架不同会分别是 spec 目录或 test 目录。</p></li>
<li><p><strong>.gemspec 文件</strong></p>

<p>这是 gem 包最重要的一个文件，它定义了 gem 包的所有元数据（metadata），包括 gem 包的作者、Email、gem 包的功能描述信息、开发模式下所依赖的其它 gem 包等等一切信息。可以去<a href="http://guides.rubygems.org/specification-reference/">这里</a>进行更全面更深入的了解和学习。</p></li>
<li><p><strong>README.md 文件</strong></p>

<p>该文件用于书写 gem 包的使用说明文档。</p></li>
</ul>


<p>除此之外的其它文件或目录保持原样就可以了，或者后期有需要再去酌情修改。</p>

<h3>实现 gem 包功能</h3>

<p>下面是时候来完成该 gem 包的功能了。</p>

<h4>完善 .gemspec 文件</h4>

<p>在书写 lib 源代码和 rspec 测试代码完成功能之前，我们先来完善一下 .gemspec 文件。上面说过，此文件是非常重要的一个文件，它描述了该 gem 包的所有信息。但目前我们不需要去了解它的全部，只关注前面几项即可，即 name ~ license 之间的信息，按照自己的需要进行修改，其它项保持不变。修改后的内容为：</p>

<figure class='code'><figcaption><span>elklogger.gemspec</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Gem</span><span class="o">::</span><span class="no">Specification</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">spec</span><span class="o">|</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">summary</span>       <span class="o">=</span> <span class="sx">%q{Specific formatted logger for ELK-stack.}</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">description</span>   <span class="o">=</span> <span class="sx">%q{Write formatted log infos to log file, used by ELK-stack.}</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">homepage</span>      <span class="o">=</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span>
</span><span class='line'>  <span class="n">spec</span><span class="o">.</span><span class="n">metadata</span><span class="o">[</span><span class="s1">&#39;allowed_push_host&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="s2">&quot;https://rubygems.org&quot;</span>
</span><span class='line'>  <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">.</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>测试驱动开发：完成功能</h4>

<p>elklogger gem 包的功能是将日志内容按照指定的格式进行格式化后输出，我们期望的格式为：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>I, [2015-12-23#8255]  INFO -- : message\n</span></code></pre></td></tr></table></div></figure>


<p>为此，我们采用 <strong>测试驱动开发</strong> 的方式，先添加 rspec 代码。打开 spec/elklogger_spec.rb 文件，添加如下代码：</p>

<figure class='code'><figcaption><span>spec/elklogger_spec.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">describe</span> <span class="no">Elklogger</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">it</span> <span class="s1">&#39;has a formmatted output&#39;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;/tmp/elklogger_test.log.elk&#39;</span>
</span><span class='line'>    <span class="n">logger</span> <span class="o">=</span> <span class="no">Elklogger</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'>    <span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s1">&#39;hello test!&#39;</span>
</span><span class='line'>    <span class="n">logger</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">file</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'>    <span class="n">reg</span> <span class="o">=</span> <span class="sr">/I, \[</span><span class="si">#{</span><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-%d&#39;</span><span class="p">)</span><span class="si">}</span><span class="sr">#\d+\]  INFO -- : hello test!\n/</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="o">.</span><span class="n">last</span> <span class="o">=~</span> <span class="n">reg</span>
</span><span class='line'>    <span class="n">file</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">not_to</span> <span class="n">be</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行 <code>rake spec</code>，出现测试未通过。这是正常的，因为我们还没有实现功能：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>Failures:
</span><span class='line'>
</span><span class='line'>  1) Elklogger has a formmatted output
</span><span class='line'>     Failure/Error: expect(result).not_to be nil
</span><span class='line'>
</span><span class='line'>       expected not #&lt;NilClass:8> => nil
</span><span class='line'>                got #&lt;NilClass:8> => nil
</span><span class='line'>
</span><span class='line'>       Compared using equal?, which compares object identity.
</span><span class='line'>     # ./spec/elklogger_spec.rb:19:in `block (2 levels) in &lt;top (required)>'
</span><span class='line'>
</span><span class='line'>Finished in 0.00251 seconds (files took 0.0868 seconds to load)
</span><span class='line'>2 examples, 1 failure</span></code></pre></td></tr></table></div></figure>


<p>现在我们来实现 <strong>红变绿</strong> 的过程。在 lib/elklogger.rb 中实现功能：</p>

<figure class='code'><figcaption><span>lib/elklogger.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Elklogger</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">format_message</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
</span><span class='line'>    <span class="no">Formatter</span><span class="o">::</span><span class="no">Format</span> <span class="o">%</span> <span class="o">[</span><span class="n">severity</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-%d&#39;</span><span class="p">),</span> <span class="vg">$$</span><span class="p">,</span> <span class="n">severity</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>lib/elklogger/version.rb 则为这样：</p>

<figure class='code'><figcaption><span>lib/elklogger/version.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;logger&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Elklogger</span> <span class="o">&lt;</span> <span class="no">Logger</span>
</span><span class='line'>  <span class="no">VERSION</span> <span class="o">=</span> <span class="s2">&quot;0.0.1&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么再运行 <code>rake spec</code> ，发现测试通过了！</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>Elklogger
</span><span class='line'>  has a version number
</span><span class='line'>  has a formmatted output
</span><span class='line'> 
</span><span class='line'>Finished in 0.00119 seconds (files took 0.07839 seconds to load)
</span><span class='line'>2 examples, 0 failures</span></code></pre></td></tr></table></div></figure>


<h4>完善 README.md 文件</h4>

<p>OK，功能已经完成了，那么现在需要告诉别人如何使用。我们把它写在 README.md 中（限于篇幅，此例中就不显示文件内容了）。</p>

<h3>本地测试 gem 包</h3>

<p>开发完功能以后，需要进行本地自测 gem 包的功能是否符合需求。本地测试 gem 包有几种方式：</p>

<ul>
<li>bin/console</li>
</ul>


<p>bundler 提供了 bin/console 这个工具，它加载了 gem 中 lib 目录下的所有源代码，你可以用它来以 irb 交互的方式自测 gem 包所提供的功能是否正常。</p>

<ul>
<li>使用 :path 或 :git 参数</li>
</ul>


<p>在 Gemfile 中，除了使用 <code>gem 'mysql2'</code> 这样的语法直接在 source 源中查找相应的 gem 包外，gem 方法还提供了 :path 和 :git 两种参数。前者允许你将其指向一个本地的 gem 包源代码目录，后者允许你将其指向一个 git 网络路径。因此，我们可以运用 :path 参数在其他项目中对 gem 包进行本地测试，而不用每次改动后都打包成 gem 包再安装。</p>

<p>对于本例，我们在一个项目的 Gemfile 文件中添加如下一行：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="s1">&#39;elklogger&#39;</span><span class="p">,</span> <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s1">&#39;/home/path/to/elklogger&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后再 <code>bundle install</code> 就可以在项目中使用了。</p>

<ul>
<li><code>rake install:local</code></li>
</ul>


<p>前面提过，<code>bundle gem</code> 附带提供了一些有助于开发 gem 的 rake 命令，<code>rake install:local</code> 就是其中之一，该命令会将 gem 源代码打包为 .gem 文件放在 pkg 目录并安装到当前的 gemset 中（相当于 <code>rake build</code> 和 <code>gem install</code>这两个命令的合体）。在本例中，运行该命令后会生成 pkg/elklogger-0.0.1.gem 文件，同时也会被安装到当前的 gemset 中（可使用 <code>gem list | grep elklogger</code> 查找到）。如果想将该 gem 包安装到指定的 gemset 的话，在执行 <code>rake install:local</code> 之前你需要先 <code>rvm use</code> 来切换到对应的 gemset 去。</p>

<p>安装好以后，就可以在该 gemset 环境中的 ruby 文件中通过 <code>require 'elklogger'</code> 得到 Elklogger 对象，从而使用该 gem 包提供的功能了。</p>

<p><strong>NOTE:</strong> 注意这种方式不适用于类似 Rails 等项目，因为 Rails 项目使用的是 Gemfile 中定义的 gem 包依赖关系，而不是当前 gemset 中的所有包。要想在 Rails 中使用，就必须在 Gemfile 中声明，这种情况下应该使用第 2 种方式来测试。</p>

<h3>打包并发布 gem 包</h3>

<p>如果只是想单独打包并不发布该 gem，可使用 <code>rake build</code> ，执行该命令后会在 pkg 目录下生成打包后的文件。例如 elklogger-0.0.1.gem。</p>

<p>如果想打包并且同时发布出去，也很简单，使用 <code>rake release</code> 即可将打包后的 gem 包发布到 RubyGems 供他人下载和安装。但先别着急执行这个命令，在发布之前，我们还需要先提交我们的代码。由于当初 <code>bundle gem</code> 初始化 git 仓库时并没有添加源，所以我们先去 github 上新建一个仓库，然后将其作为我们 gem 包的远端源添加后再提交代码：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">origin</span> <span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="no">Gnodiah</span><span class="o">/</span><span class="n">elklogger</span><span class="o">.</span><span class="n">git</span>
</span><span class='line'><span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class='line'><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span> <span class="s1">&#39;finish develop&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>再来运行 <code>rake release</code> ，输入用户名和密码后即发布成功了。此命令做了 3 件事：</p>

<ul>
<li>运行 <code>rake build</code> 打包 gem</li>
<li>以当前的 gem 版本号在 git 分支上打一个 tag 标签</li>
<li>发布上传 gem 包到 RubyGems</li>
</ul>


<p>OK，到目前为止，elklogger gem 包已经全部完成并发布到 RubyGems 了，此时就可以使用 <code>gem install elklogger</code> 直接安装了（如果当前源没有，记得加上 &#8211;source &#8216;https://rubygems.org&#8217;）。</p>

<p>最后的最后，别忘了 push 源代码到 git 仓库：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">master</span>
</span></code></pre></td></tr></table></div></figure>


<h3>弦外之音</h3>

<ol>
<li>与 <code>bundle gem</code> 功能类似的还有 <a href="https://github.com/technicalpickles/jeweler">jeweler</a>，可以去了解一下。但现在可能没有 bundler 这么流行，Github 上也很久没有更新了。</li>
<li>Github 上大家也总结了这么一篇文章： <a href="https://github.com/radar/guides/blob/master/gem-development.md">Developing a RubyGem using Bundler</a>，值得一看。</li>
</ol>


<p><em>（注：本文使用的 bundler 版本是 1.11.2）</em></p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[rails_config的正确使用姿势]]></title>
<link href="http://haydenwei.com/posts/2015/04/rails-config-usage"/>
<updated>2015-04-26T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/04/rails-config-usage</id>

      <content type="html"><![CDATA[<p>还记得我们在很多 Rails 项目中，将配置信息写到 config/settings.yml 文件，然后在代码中使用类似于 <code>Settings.service.host</code> 这样的用法来读取配置文件的情景吗？咋一看还以为这是 Rails 本身提供的特性，其实并不是，而是 <a href="https://github.com/railsconfig/rails_config">rails_config</a> 这个 gem 包提供给我们的。虽然 Settings 看起来是一个常量(<em>因为以大写字母开头</em>)，但实际上它是 RailsConfig::Options 类的一个实例对象，包含了当前项目中所有 settings 文件中配置的 key-value 对。</p>

<p>它有两种使用方式：</p>

<ul>
<li>Settings.key(.sub_key)</li>
<li>Settings[:key][:sub_key] 或 Settings[&#8216;key&#8217;][&#8216;sub_key&#8217;]</li>
</ul>


<h3>Settings使用姿势说明</h3>

<p>rails_config 默认的 settings 文件有 6 个，分别为:</p>

<ul>
<li>config/settings.yml</li>
<li>config/settings.local.yml</li>
<li>config/settings/#{Rails.env}.yml</li>
<li>config/settings/#{Rails.env}.local.yml</li>
<li>config/environments/#{Rails.env}.yml</li>
<li>config/environments/#{Rails.env}.local.yml</li>
</ul>


<p>因此，在使用 Settings 过程中会存在两个问题：</p>

<ol>
<li>同一个 setting 文件的内容是如何被解析的？</li>
<li>不同 settings 文件的内容是如何被解析和合并的？</li>
</ol>


<p>我们先来看结果：</p>

<p>1、同一个 setting 文件中的相同 key 之间是 <strong>覆盖关系</strong>。(后者会直接整个覆盖掉前者，不会对子节点 key 进行合并)</p>

<figure class='code'><figcaption><span>config/settings.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">1</span>
</span><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">2</span>
</span><span class='line'>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="mi">127</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">8983</span>
</span><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="mi">192</span><span class="o">.</span><span class="mi">168</span><span class="o">.</span><span class="mi">100</span><span class="o">.</span><span class="mi">46</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; 2</span>
</span><span class='line'><span class="c1"># Settings.solr.host #=&gt; 192.168.100.46</span>
</span><span class='line'><span class="c1"># Settings.solr.port #=&gt; nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、同一个 setting 文件与其 .local 文件中相同 key 之间是 <strong>合并关系</strong>。（.local 文件优先级更高）</p>

<figure class='code'><figcaption><span>config/settings.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">host</span><span class="p">:</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="mi">127</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">.</span><span class="mi">1</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">8983</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>config/settings.local.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">solr</span><span class="p">:</span>
</span><span class='line'>  <span class="n">username</span><span class="p">:</span> <span class="s1">&#39;Hayden&#39;</span>
</span><span class='line'>  <span class="n">port</span><span class="p">:</span> <span class="mi">12121</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.solr.host #=&gt; &quot;http://127.0.0.1&quot;</span>
</span><span class='line'><span class="c1"># Settings.solr.port #=&gt; 12121</span>
</span><span class='line'><span class="c1"># Settings.solr.username #=&gt; &quot;Hayden&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、不同 settings 文件的 key 之间的关系是 <strong>合并关系</strong>。且优先级关系从高到低依次为:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='plain'><span class='line'>config/environments/#{Rails.env}.local.yml >
</span><span class='line'>config/settings/#{Rails.env}.local.yml >
</span><span class='line'>config/settings.local.yml >
</span><span class='line'>config/environments/#{Rails.env}.yml >
</span><span class='line'>config/settings/#{Rails.env}.yml >
</span><span class='line'>config/settings.yml</span></code></pre></td></tr></table></div></figure>


<p>4、不同 settings 文件的相同 key 在合并过程中的原则是：</p>

<ul>
<li>如果 key 对应的 value 是不同类型或不可合并的类型时，对 value 进行覆盖；</li>
<li>如果 key 对应的 value 是可以合并的类型(比如数组)时，则对 value 进行合并。</li>
</ul>


<figure class='code'><figcaption><span>config/settings.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">88</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>config/settings.loca.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; [11, 88, 23, 45]</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、在第 4 点中，如果中途被打断，则还是会对 value 进行覆盖操作，而不是合并。</p>

<figure class='code'><figcaption><span>config/settings.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">88</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>config/settings/development.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="mi">2</span>   <span class="c1"># 这里中途被不同类型的value打断</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>config/settings.local.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">change_pwd_switch</span><span class="p">:</span> <span class="o">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">45</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Settings.change_pwd_switch #=&gt; [23, 45]</span>
</span></code></pre></td></tr></table></div></figure>


<p>6、在 development 模式下，每一次页面请求都会调用 <code>Settings.reload!</code> 来重新加载和解析所有的 settings 文件，因此理论上修改了 settings 文件后不需要重启 Rails。
7、在 settings 文件中是允许内嵌 ruby 代码的，这在某些情况下很有用。例如：</p>

<figure class='code'><figcaption><span>config/settings.yml</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">size</span><span class="p">:</span> <span class="mi">2</span>
</span><span class='line'><span class="n">computed</span><span class="p">:</span> <span class="o">&lt;</span><span class="sx">%= 1 + 2 + 3 %&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sx"># Settings.computed #=</span><span class="o">&gt;</span> <span class="mi">6</span>
</span></code></pre></td></tr></table></div></figure>


<h3>追根溯源</h3>

<p>我们先来了解下 rails_config 在 Rails 启动过程中做了什么：</p>

<p>1、加载 config/initializers/rails_config.rb 文件，该文件是 rails_config 的自定义文件。例如，如果你不想使用默认的 Settings 来引用配置文件，就可以在该文件中进行修改其常量名称：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">RailsConfig</span><span class="o">.</span><span class="n">setup</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">const_name</span> <span class="o">=</span> <span class="s2">&quot;MySettings&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、加载所有默认的 settings 配置文件，将其解析为一个 RailsConfig::Options (继承自<a href="http://ruby-doc.org/stdlib-2.1.1/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a>，是一个类似于 Hash 的数据结构)对象，并将该对象赋值给 Settings 常量，以便我们通过 <code>Settings.xxx</code> 的方式来调用。</p>

<hr />

<p><strong>Q1: 上面所说的 6 个 settings 文件是有优先级的，为什么必须是这样的顺序呢？</strong></p>

<p><strong>A1:</strong> 没有其他原因，仅仅是因为 rails_config 的代码中是这样定义死的，源码如下：</p>

<figure class='code'><figcaption><span>lib/rails_config/integration/rails.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">RailsConfig</span><span class="o">.</span><span class="n">load_and_set_settings</span><span class="p">(</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;environments&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;environments&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">Rails</span><span class="o">.</span><span class="n">env</span><span class="si">}</span><span class="s2">.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难看出，方法传入的是一个数组参数，在用 <code>each</code> 遍历时，后者必然会覆盖前者，因而自然就产生了如上所说的优先级顺序。</p>

<p><strong>Q2: 我不想使用默认的优先级顺序，我想在运行时改变它们之间的顺序；我还想加入自己的 yml 配置文件&#8230;可以吗？</strong></p>

<p><strong>A2:</strong> 完全没有问题。</p>

<p>1、如果想在默认的6个 settings 配置文件基础上加入自己的 yml 配置文件，你可以在程序中任何需要的地方加入如下代码片段：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">add_source!</span><span class="p">(</span><span class="s2">&quot;/path/to/my_settings.yml&quot;</span><span class="p">)</span>
</span><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">reload!</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时你的 my_settings.yml 文件中的配置就可以直接用 <code>Settings.xxx</code> 来调用了，而且你的 my_settings.yml 文件拥有最高的优先级。</p>

<p>2、如果你想完全自定义需要加载的 settings 文件及其顺序，可以在程序中任何需要的地方加入如下代码片段：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Settings</span><span class="o">.</span><span class="n">reload_from_files</span><span class="p">(</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;settings.local.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'>  <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;config&quot;</span><span class="p">,</span> <span class="s2">&quot;my_settings.yml&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样 Settings 中就只包含了 settings.local.yml 和 my_settings.yml 中的配置。</p>

<p><strong>Q3: 我很好奇它的解析和合并算法，它是怎么实现的呢？</strong></p>

<p><strong>A3:</strong> 这是 rails_config 中最核心和最重要的部分了，其实现封装在 <code>DeepMerge</code> 这个 module 中。如有兴趣可以直接阅读源码来了解它的实现，<a href="https://github.com/railsconfig/rails_config/blob/master/lib/rails_config/vendor/deep_merge.rb">源码传送门在这里</a>。即使不想阅读源码，但了解它的存在也是有必要的。因为如果以后你自己的项目中遇到要解析和合并多个yml文件的内容时，可以直接拿来使用，或者参考它的实现，毕竟我们还是要把时间用在更有意义的地方，避免重复造轮子。</p>

<p><em>（注：本文内容基于 rails_config 0.3.1版本，目前 rails_config 的最新稳定版为0.4.2。虽然版本有所升级，但核心设计应该不会有变化。如有疑问，欢迎指出并留言讨论。）</em></p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[理解ActiveRecord::Relation.where等方法的查找链]]></title>
<link href="http://haydenwei.com/posts/2015/03/activerecord-relation-methods-lookup-chain"/>
<updated>2015-03-20T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/03/activerecord-relation-methods-lookup-chain</id>

      <content type="html"><![CDATA[<p>阅读完本篇文章，你将了解到：</p>

<ul>
<li>类似 Book.where(id: 1) 这样的方法是如何执行的</li>
<li>ActiveRecord::Relation 对象是什么</li>
</ul>


<h3>理解where方法的查找链</h3>

<p>假设我们有一个名为 Book 的 model:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Book</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>再假设我们要查询id为1的那本书，以 <code>where</code> 方法为例，那么我们的查询语句一般会这样写: <code>Book.where(id: 1)</code>；但在Book类中你并没有定义 <code>where</code> 方法，那么这句代码是怎样被执行的呢？让我们一起来探究一下。</p>

<p>1、首先，Book 类中没有定义 where 方法；但由于 Book 类继承自 ActiveRecord::Base 类，因此方法调用链会去尝试调用 ActiveRecord::Base.where 方法。</p>

<p>2、通过查看ActiveRecord::Base类的源码可知，ActiveRecord::Base类也没有显式定义where方法；但ActiveRecord::Base类extend了ActiveRecord::Querying模块：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">Querying</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、ActiveRecord::Querying模块也没有显式定义where方法，它使用了<code>delegate</code>委派技术将对ActiveRecord::Querying.where的调用转换为调用scoped.where，源码如下：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/querying.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span>
</span><span class='line'>         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:uniq</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:scoped</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、可见，Rails将where、group、includes等常用的查询方法都代理到了scoped之上。那么scoped是什么呢？它是ActiveRecord::Scoping::Named模块里的一个方法，用于创建一个空的scope:</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping/named.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">scoped</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">options</span>
</span><span class='line'>    <span class="n">scoped</span><span class="o">.</span><span class="n">apply_finder_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">current_scope</span>
</span><span class='line'>      <span class="n">current_scope</span><span class="o">.</span><span class="n">clone</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span>
</span><span class='line'>      <span class="n">scope</span><span class="o">.</span><span class="n">default_scoped</span> <span class="o">=</span> <span class="kp">true</span>
</span><span class='line'>      <span class="n">scope</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、由于我们调用scoped.where时并没有传入options和current_scope这两个参数，因此scoped方法的执行逻辑会进入到最后一个else语句。那么问题来了，这里的scoped方法是属于谁的呢，怎么可以直接被Book类调用呢？</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/scoping.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Scoping</span>
</span><span class='line'>    <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>
</span><span class='line'>    <span class="n">included</span> <span class="k">do</span>
</span><span class='line'>      <span class="kp">include</span> <span class="no">Named</span> <span class="c1"># ActiveRecord::Scoping模块include了ActiveRecord::Scoping::Named模块</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From:  ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Base</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">Scoping</span> <span class="c1"># 而ActiveRecord::Base又include了ActiveRecord::Scoping模块</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>6、ActiveRecord::Base类通过include ActiveRecord::Scoping模块而引入了scoping方法，因此Book类才能够调用。现在回到上一步，由于执行逻辑进入了最后一个else语句，那么代码<code>scope = relation</code>会首先被执行。<code>relation</code>是定义在ActiveRecord::Base类的一个private方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/base.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">private</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">relation</span>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span>
</span><span class='line'>    <span class="n">relation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">)</span><span class="o">.</span><span class="n">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="o">.</span><span class="n">to_sym</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">relation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>7、可以看出，ActiveRecord::Base.relation方法很简单，仅仅new了一个ActiveRecord::Relation实例便返回了。其中self表示当前的调用类，即本例的Book类。也就是说，ActiveRecord::Base.relation方法返回了一个包含当前调用类表字段信息的Relation对象。</p>

<p>8、第7步完成后，就表示完成了对<code>scoped</code>方法的调用，返回的是一个ActiveRecord::Relation对象。还记得第3步中所说的吗？对ActiveRecord::Base.where的调用委派为调用scoped.where；现在由于<code>scoped</code>返回的是ActiveRecord::Relation对象，因此就转换为调用ActiveRecord::Relation#where方法了。ActiveRecord::Relation通过include ActiveRecord::QueryMethods模块引入了where方法：</p>

<figure class='code'><figcaption><span>~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation.rb</span></figcaption><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ActiveRecord</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Relation</span>
</span><span class='line'>    <span class="kp">include</span> <span class="no">FinderMethods</span><span class="p">,</span> <span class="no">Calculations</span><span class="p">,</span> <span class="no">SpawnMethods</span><span class="p">,</span> <span class="no">QueryMethods</span><span class="p">,</span> <span class="no">Batches</span><span class="p">,</span> <span class="no">Explain</span><span class="p">,</span> <span class="no">Delegation</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># From: ~/.rvm/gems/ruby-2.1.1@rails3_2_13/gems/activerecord-3.2.13/lib/active_record/relation/query_methods.rb</span>
</span><span class='line'><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">self</span> <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">blank?</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">relation</span> <span class="o">=</span> <span class="nb">clone</span>
</span><span class='line'>  <span class="n">relation</span><span class="o">.</span><span class="n">where_values</span> <span class="o">+=</span> <span class="n">build_where</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
</span><span class='line'>  <span class="n">relation</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>9、where方法中需要注意的是<code>build_where</code>这个方法，该方法会最终调用ActiveRecord::Sanitization.sanitize_sql_for_conditions方法来将你传入到where方法中的查询条件转化为一个有效的SQL语句字符串片段。<strong>值得注意的是以Hash的形式传入时是有所不同的。</strong>例如：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span>  <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;id = 1&quot;</span><span class="o">]</span><span class="p">)</span> <span class="c1">#=&gt; 返回[&quot;id = 942998&quot;]</span>
</span><span class='line'><span class="no">Book</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1">#=&gt; 返回包含id=1查询条件的Arel::Nodes::Equality对象数组</span>
</span></code></pre></td></tr></table></div></figure>


<p>10、当build_where方法返回后，整个<code>where</code>方法也就是返回了。到此为止，你对<code>books = Book.where(id: 1)</code>的调用就算是完全执行完了。那么得到的books是什么呢？是你想要的id为1的这本书的信息吗？不是！从上面整个执行过程我们已经得到答案了，<strong>这里的books只是一个ActiveRecord::Relation对象，该对象包含了当前调用类Book的表信息，还包含了需要执行的查询条件的SQL语句，仅此而已。也就是说，这时并没有真正地去连接数据库进行查询。</strong>那么问题又来了，Rails什么时候才去查询数据库呢？</p>

<h3>ActiveRecord::Relation对象何时查询数据库？</h3>

<p>1、想象一下我们通常对ActiveRecord::Relation对象做些什么操作？比如上面得到的books对象，我们通常会有这样的操作：</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">books</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">book</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">p</span> <span class="n">book</span><span class="o">.</span><span class="n">id</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、books是一个ActiveRecord::Relation对象，那么ActiveRecord::Relation.each方法是什么呢？</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate</span> <span class="ss">:to_xml</span><span class="p">,</span> <span class="ss">:to_yaml</span><span class="p">,</span> <span class="ss">:length</span><span class="p">,</span> <span class="ss">:collect</span><span class="p">,</span> <span class="ss">:map</span><span class="p">,</span> <span class="ss">:each</span><span class="p">,</span> <span class="ss">:all?</span><span class="p">,</span> <span class="ss">:include?</span><span class="p">,</span> <span class="ss">:to_ary</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:to_a</span>
</span></code></pre></td></tr></table></div></figure>


<p>3、可见Rails将我们常用的each、map等方法都委派到了ActiveRecord::Relation.to_a方法上:</p>

<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">to_a</span>
</span><span class='line'>  <span class="c1"># We monitor here the entire execution rather than individual SELECTs</span>
</span><span class='line'>  <span class="c1"># because from the point of view of the user fetching the records of a</span>
</span><span class='line'>  <span class="c1"># relation is a single unit of work. You want to know if this call takes</span>
</span><span class='line'>  <span class="c1"># too long, not if the individual queries take too long.</span>
</span><span class='line'>  <span class="c1">#</span>
</span><span class='line'>  <span class="c1"># It could be the case that none of the queries involved surpass the</span>
</span><span class='line'>  <span class="c1"># threshold, and at the same time the sum of them all does. The user</span>
</span><span class='line'>  <span class="c1"># should get a query plan logged in that case.</span>
</span><span class='line'>  <span class="n">logging_query_plan</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">exec_queries</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、继续升入to_a方法内部，它调用exec_queries方法</p>
]]></content>
    </entry>
  
    <entry>
      




<title type="html"><![CDATA[谈谈对云计算的一些理解]]></title>
<link href="http://haydenwei.com/posts/2015/03/cloud-computing-and-openshift"/>
<updated>2015-03-03T00:00:00+08:00</updated>
<id>http://haydenwei.com/posts/2015/03/cloud-computing-and-openshift</id>

      <content type="html"><![CDATA[<p>现如今无论公司还是个人，都在讲云计算，似乎一听到<strong>云计算</strong>这个词就觉得高大上。那么到底什么是云计算呢？</p>

<h3>什么是云计算？</h3>

<p>目前使用最多的对云计算的定义是这样的：</p>

<blockquote><p><strong>云计算</strong>是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p></blockquote>

<p>以上是美国国家标准技术研究所（NIST）给出的<a href="http://www.nist.gov/itl/cloud/">定义</a>，大家千万不要被云计算这三个字中的“计算”两个字所误导而认为这是一种关于数学计算方面的新技术；实际上它代表的是一种模型或者叫模式。</p>

<p>举个例子来说，我做了一个网站来提供图片存储服务，你通过访问网站来上传和下载你存储的图片。对于你（使用者）来说，上传的图片存到什么地方去了、后台有多少台服务器、服务器的网络带宽是多少&#8230;等等这些问题你一无所知，就像被云遮住了一样什么都看不见（整个网站服务就像是一朵云，你把图片扔进云里它就存储好了，要用的时候直接从云里去拿，至于这是一朵什么云你一概不知也不需要知道，这就是<strong>云</strong>的概念）；再加上这些服务都跟计算机或者大量计算相关，所以类似于我提供的这种服务模式就叫做<strong>云计算</strong>，而我就叫做<strong>云计算服务提供方</strong>。</p>

<p>目前云计算领域主要包含3大部分内容，即Infrastructure as a Service（IaaS，基础设施即服务）、Platform as a Service（PaaS，平台即服务）、 Software as a Service（SaaS，软件即服务）。</p>

<h3>IaaS, PaaS和SaaS的区别</h3>

<p>IaaS, PaaS和SaaS是目前云计算领域的主要组成部分。如果把整个云计算想象成一个栈的话，那么IaaS就在最底层，SaaS在最顶层，而PaaS在它们之间。</p>

<p><img src="http://7x2vza.com1.z0.glb.clouddn.com/cloud-computing.png" alt="云计算" /></p>

<ul>
<li><p><strong>IaaS（基础设施即服务）</strong></p>

<p>IaaS是一种将服务器、存储资源、网络配置、防火墙等一系列基础设备综合起来提供给用户按需付费使用的服务。</p>

<p>例如，一个公司如果需要上线一个web产品，那么运维部需要提前采购服务器、购买网络带宽、配置网络和防火墙等等，往往光是采购服务器这一步就可能需要花费一周的时间，大大延迟了产品的上线时间；而且每次新增服务器都需要重复以上过程。有了IaaS以后，你只需要考虑选择哪一个IaaS服务提供方，选定后按自己对基础资源的需求购买相应的资源即可（大部分IaaS提供方都可以免费试用），所有关于采购、配置等步骤你都不用管，你只需要在购买的资源上配置运行公司的产品所需要的环境即可。这让你仅仅聚焦于如何搭建和发布产品环境而不是繁琐的服务器采购和配置工作。</p>

<p>目前IaaS服务主要提供云存储和硬件资源虚拟化（比如上例中的服务器资源），在这方面做的最好最大的是<a href="http://aws.amazon.com/cn/">Amazon Web Service（AWS）</a>，国内也有诸如<a href="http://www.qcloud.com/">腾讯云</a>这样的服务。</p></li>
<li><p><strong>PaaS（平台即服务）</strong></p>

<p>PaaS通常是在IaaS基础上提供的一种平台服务，且多聚焦于web解决方案。它在IaaS基础上将运行某一语言所需要的环境安装好后直接提供给用户（<strong>主要是开发者</strong>）使用，让用户专注于产品的创新和快速原型的开发，而不是完成从购买服务器、安装产品运行环境到部署代码等整个繁琐的过程。</p>

<p>比如，你有一个很好的idea，已经用Rails来实现了它，现在迫切需要发布到网上进行推广验证。因此接下来你要购买一个服务器、购买域名、安装和配置Nginx、安装Ruby和Rails、安装MySQL数据库&#8230;然后部署代码进行测试是否部署成功。天啦，想想都觉得头痛！现在有了PaaS，你只需要两步：第一步选择开发平台（比如Rails），第二步提交代码，然后就可在线上进行访问了。所有有关该开发平台的环境配置、服务器配置、数据库安装都由PaaS帮你完成，让你更专注于代码开发从而快速实现一个好的创意。</p>

<p>PaaS平台现在有很多，比如GAE，OpenShift，Heroku，国内的SAE， BAE等等。</p></li>
<li><p><strong>SaaS（软件即服务）</strong></p>

<p>  回想一下我们平常是怎样使用软件的？当我们需要使用一个软件时，我们需要下载它、安装它，然后才能使用，此时该软件是实实在在存在于我们的计算机上的。比如在以前你要收发邮件时需要下载并安装邮件客户端，还需要配置POP/SMTP地址，而且还需要时刻小心垃圾邮件占尽了磁盘空间，当软件有更新时你还需要下载更新&#8230;但有了SaaS就不一样了，再想一下你使用Gmail的场景：你仅仅在浏览器中输入了一个网址，再登录以后居然就可以收发邮件了。</p>

<p>这就是SaaS，它是一种通过Internet提供软件的模式，用户无需购买和安装软件，直接向提供方租用（免费或者付费）基于Web的软件。典型的SaaS应用有Gamil, <a href="https://office.live.com">Microsoft Office Online</a>等等。</p></li>
</ul>


<p>当然，作为一名开发者，最为关心的应该就是PaaS了，因此下面就来谈谈OpenShift的使用。</p>

<h3>OpenShift的使用</h3>

<h4>1. 什么是OpenShift？</h4>

<p><a href="https://www.openshift.com/">OpenShift</a>是Red Hat公司推出的一种PaaS服务，它支持Java（Wildfly, JBossEAP, Tomcat）, PHP, Node.js, Python, Ruby, Perl, MySQL, PostgreSQL, MongoDB, Jenkins, Cron, 以及JBoss xPaaS Services (Fuse, BPM Suite, BRMS, Data Virtualization, Aerogear等等)，可以说包含了目前所有的主流开发平台。</p>

<p>OpenShift提供了3种版本：OpenShift Origin，OpenShift Online和OpenShift Enterprise。其中OpenShift Origin开源并托管于<a href="https://github.com/openshift/origin">Github</a>上，你可以用它来搭建自己的本地PaaS服务；OpenShift Online则是定期从OpenShift Origin打包发布的主要针对开发者的PaaS服务；而OpenShift Enterprise则主要提供给企业用户使用。因此作为开发者来讲，我们主要关心并使用的是OpenShift Online。</p>

<p><a href="https://www.openshift.com/app/account/new">注册</a>一个OpenShift Online账号后，每个账号就可以<strong>免费</strong>创建并部署3个小应用程序了（small gear），每个应用程序的服务器配置为 512M RAM 和 1G 存储容量，这对于个人项目或者刚刚诞生的Good idea来说已经足够了。</p>

<h4>2. 安装OpenShift</h4>

<p>OpenShift提供了3种方式来创建和管理应用程序：Web Console、客户端命令行工具rhc，以及Eclipse插件。对绝大多数开发者来说最强大最完整的方式肯定是命令行工具，因此下面就以在CentOS系统上使用命令行工具rhc创建一个Ruby应用的方式来简单介绍一下OpenShift的使用。其他系统安装rhc的方法请参考<a href="https://developers.openshift.com/en/managing-client-tools.html">这里</a>。</p>

<ul>
<li><p>准备条件</p>

<p>rhc是一个Gem包，因此你需要先安装RubyGems。Ruby 1.9+已经内置了RubyGems，所以如果你的系统上已经安装过Ruby 1.9+的版本的话，RubyGems就已经在你的系统上了。如果没有安装过请参考<a href="https://rubygems.org/pages/download">这里</a>。此外，rhc使用SSH和Git来管理和上传源代码，因此这两个工具也需要安装。</p></li>
<li><p>安装rhc</p></li>
</ul>


<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="n">install</span> <span class="n">rhc</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>运行 <code>rhc setup</code> 按提示一步一步<a href="https://developers.openshift.com/en/getting-started-overview.html">配置rhc</a></p></li>
<li><p>配置完成后，即可创建一个应用程序：</p></li>
</ul>


<figure class='code'><div class='highlight'><table><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># 可运行rhc cartridge list查看OpenShift支持的所有开发平台</span>
</span><span class='line'><span class="c1"># 创建一个名称为funny的应用程序，开发平台为ruby-2.0</span>
</span><span class='line'><span class="n">rhc</span> <span class="n">create</span><span class="o">-</span><span class="n">app</span> <span class="n">funny</span> <span class="n">ruby</span><span class="o">-</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<p>OK，就这4步，一个名为funny的Ruby应用程序已经创建并部署到OpenShift上了，现在你就可以访问OpenShift返回给你的应用程序URL来查看它了，厉害吧！</p>

<p>但遗憾的是上述URL并不能在华夏国内访问，因为它已经被功夫网（GFW）给封了。好在<strong>绑定独立域名后是可以访问的</strong>。具体方法为：</p>

<ol>
<li>首先在你所购买的域名的管理界面中新增域名解析CNAME类型，将OpenShift给你的应用程序的URL解析到你所购买的域名；</li>
<li>在OpenShift应用程序根目录中执行<code>rhc alias add &lt;应用程序名称&gt; &lt;你购买的域名&gt;</code>绑定独立域名。</li>
</ol>


<p>OK，刚刚部署的应用程序现在终于可以正常访问了。关于rhc的更多用法请运行<code>rhc -h</code>查看。要了解更多的OpenShift知识或查看每种开发平台的帮助文档请阅读OpenShift的<a href="https://developers.openshift.com/">开发者文档</a>。</p>
]]></content>
    </entry>
  
</feed>
